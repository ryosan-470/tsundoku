<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ryosan-470の積ん読ブログ</title>
    <link>https://ryosan-470.github.io/tsundoku/posts/</link>
    <description>Recent content in Posts on ryosan-470の積ん読ブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 24 Nov 2019 19:00:00 +0900</lastBuildDate>
    
	<atom:link href="https://ryosan-470.github.io/tsundoku/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分散システム入門</title>
      <link>https://ryosan-470.github.io/tsundoku/posts/introfuction_of_distributed_systems/</link>
      <pubDate>Sun, 24 Nov 2019 19:00:00 +0900</pubDate>
      
      <guid>https://ryosan-470.github.io/tsundoku/posts/introfuction_of_distributed_systems/</guid>
      <description>A Thorough Introduction to Distributed Systems https://medium.com/free-code-camp/a-thorough-introduction-to-distributed-systems-3b91562c9b3c
はじめに 世界における技術のますますの発展とともに分散システムもますます広がってきました。それらはコンピューターサイエンスの分野において複雑で巨大なものとなっています。
この記事では分散システムの基本的な方法について紹介し、システムの深い詳細を紹介するのではなく分散システムの異なるカテゴリに関して垣間見ることになります。
分散システムとはなにか 分散システムの最も単純な定義はエンドユーザーには1つのコンピュータのように見えるように連携して動作するコンピュータの集合です。 これらのマシンは状態を共有しており、同時に動作し、システム全体への影響を及ぼさず独立して障害を起こします。 私はあなたがそれを全てよりよく理解できるようにシステムを分散させる例を通して段階的に取り組むことを提案します。
データベースを使ってみましょう。従来のデータベースは情報を取得/挿入したいときはいつでも1つのマシンのファイルシステムに保存しているため、そのマシンと直接やり取りをします。 このデータベースシステムでの分散とは、同じときに複数のマシンでこのデータベースを動かすことになります。ユーザーは自分が選択したどのマシンともやりとりでき、単一のマシンと会話していないことを伝えることはできません。もしノード 1にレコードを挿入すると、ノード3はそのレコードを返すことができます。
どうして分散システムなのか システムは常に必要に応じて分散されます。問題の真実は分散システムの管理は落とし穴と地雷でいっぱいな複雑なトピックであるということです。デプロイや維持、分散システムのデバッグは頭痛の種であり、どうしてそちらに行くのでしょうか?
分散システムが可能にすることは水平方向へのスケール です。1つのデータベース・サーバーがある例に戻ってみると、更に多くのトラフィックをさばくための唯一の方法はデータベースが動いているハードウェアをアップグレードすることだけでした。これを 垂直方向のスケーリング と呼びます。
水平方向のスケーリング はハードウェアをアップグレードするということではなく単に更に多くのコンピューターを追加するということです。
特定のしきい値を超えた後の垂直方向のスケーリングよりも大幅に安価ですが、それが優先されるような主なケースではありません。
垂直方向のスケーリングはパフォーマンスを最新のハードウェアの性能まで引き上げることができるだけです。この性能は中程度から大きなワークロードを抱えるテクノロジー企業にとっては不十分であるということが証明されています。
水平方向のスケーリングにおける最善なことはスケールできる量に制限がないということです。つまりいつでもパフォーマンスが劣化した環境に他のマシンを追加することで無限の可能性を秘めた性能を引き出すことができます。
分散システムから得られる利点は簡単なスケーリングだけではありません。フォールトトレランス と低遅延 も同様に重要です。
 フォールトトレランス 2つのデータセンターにまたがって10台のマシンのクラスターは本質的に単一のマシンよりも耐性があります。もし1つのデータセンターが焼失してもアプリケーションは稼働し続けられます。 低遅延 世界を旅するネットワークパケットの時間は光の速度という制約が物理的に存在します。例えばニューヨークとシドニー間の光ファイバーケーブル内の往復時間 (RTT) は最も短くて160msです。分散システムは2つの街にノードをおき、近いノードからトラフィックを返すことができます。  しかし分散システムを動かすためには具体的に同じ時間で複数のコンピューターに動かし、問題が起きた場合に対処するソフトウェアが必要です。これは簡単ではありません。
データベースをスケーリングする Webアプリケーションが大変有名になったと想像してみてください。さらに私達のデータベースが扱うクエリが秒間で2倍になったと想像してみてください。アプリケーションはすぐさまパフォーマンスが低下し、ユーザーはそれに気づくでしょう。
では一緒にデータベースをスケールアップし高負荷に耐えられるようにしていきましょう。
典型的なWebアプリケーションでは新しい情報を挿入したり古い情報を修正するよりも情報を読み取ることのほうが多いです。
読み取りパフォーマンスを向上する方法としてマスタースレーブレプリケーション 戦略と呼ばれる方法があります。ここでは新しく2つのデータベースサーバーをつくりメインのものと同期させます。これら2つのインスタンスからのみ読み取るようにします。
情報を修正または挿入するときはいつでもマスターデータベースに接続しに行きます。それは順番に変更をスレーブに非同期的に通知しデータを保存します。
おめでとうございます。ついに3倍もの読み込みクエリを実行できるようになりました。これでよいでしょうか?
分散システムのカテゴリ 落とし穴 さて、データベースのACID 保証のうちC で表される一貫性が抜け落ちています。 ご存知の通り、ここには新しいレコードをデータベースにインサートしてすぐにそれを取得する読み込みクエリを実行すると何も返ってこないという問題があります。
マスターからスレーブへの新しい情報の伝搬は瞬時には行われません。実際には古くなった情報を取得できる時間枠があります。そうでない場合は、データが伝搬されるのを同期的に待つ必要があるため書き込みパフォーマンスが低下します。
分散システムにはいくつかのトレードオフがあります。特にこの問題は適切に拡張したいときに対処しなければならない問題です。
スケールアップを継続する スレーブデータベースを利用するという手法では、ある程度の範囲まで読み込みトラフィックを水平にスケールアップすることができます。これは大変素晴らしいのでしが、書き込みトラフィックにはどこかで上限があることになります。なぜなら書き込みは1台でしか対応できていないからです。
ここにはあまり選択肢がありません。書き込みトラフィックを処理することができないために書き込みトラフィックを複数のサーバーに分割する必要があります。
1つの方法はマルチマスターレプリケーション戦略を取ることです。スレーブからは読み込むだけだったことの代わりに、複数のマスターノードを持ち、読み書きに対応させるようにします。ただ残念なことに重複を作成してしまうという (例えば2つのレコードを同じIDでインサートする)複雑な問題が発生します。
もう一つの方法としてシャーディング (またはパーティショニング)とよばれる方法を見てみましょう。
サーバーを複数の小さなサーバー二分割してシャーディングしたものをシャード と呼びます。これらのシャードはすべて異なるレコードを持っています。なので何のレコードをどのシャードにするかというルールを作成します。データが一様に分散されるようにルールを作ることは大変重要です。
よくある手法としてレコードにおける情報の範囲によって定義するという方法があります。(例えばユーザー名がA~D)
このシャーディングキーは任意のカラムと等しくない読み込みが発生するため、慎重に選ぶ必要があります。(例えば多くの人々の名前はZよりもCから始まる) 多くのリクエストを他のシャードよりも受け取るシャードのことを ホットスポット とよびこれは避けなければなりません。一度分割したものを再度シャーディングしなおすことは信じられないほど大変コストがかかるもので、FourSquareの11時間の障害のように多くのダウンタイムを引き起こすことになります。</description>
    </item>
    
    <item>
      <title>Test Flakiness – Methods for identifying and dealing with flaky tests</title>
      <link>https://ryosan-470.github.io/tsundoku/posts/test_flakiness/</link>
      <pubDate>Sun, 24 Nov 2019 18:58:53 +0900</pubDate>
      
      <guid>https://ryosan-470.github.io/tsundoku/posts/test_flakiness/</guid>
      <description>Spotifyのエンジニアリングブログより。CIで起きる時折ランダムに落ちるようなテストのことをFlakyなテストとよびそれらについて、さらにその原因やSpotifyではどのように対処しているか、書かれている
 Test Flakiness – Methods for identifying and dealing with flaky tests https://labs.spotify.com/2019/11/18/test-flakiness-methods-for-identifying-and-dealing-with-flaky-tests/
2019年9月12日、私はトロントで開かれた、Assert(JS) で Spotify におけるテスト Flakiness と、flakiness に対応するために長年に渡って構築してきたシステムのいくつかについて発表しました。
Assert(JS) はウェブシステムにおける完全自動化テストを専門とするカンファレンスで開催されて2年目になります。このカンファレンスは自動化テストの世界で広く知られている、Kent Dodds、Justin Searls、Aaron Abramov、James ShoreとIsaac Schlueterがスピーカーとして開催されているイベントです。
テスト flakiness とはなにか? flakyなテスト (訳注: 以降は不安定なテスト と訳します) とは、コードの変更がないのにも関わらず定期的に成功したり失敗したりするテストのことを指しています。不安定なテストは間違いなく迷惑であり、エンジニアはCIでビルド全体を再トリガーする必要があり、多くの場合新しいビルドが正常に完了するのを待つことに多くの時間を要するため、非常にコストがかかるものになります。
しかし実際の不安定なテストによる損失は、テストに対する信頼性の欠如にあります。テストに自信がない場合、テストを行わないチームよりも優位な立場にあります。不安定なテストは自信を持って継続的に配信する能力に大きく影響します。
flakinessの原因 不安定なテストの原因は多く存在しますが、私の講演では以下を強調して話します。
 一貫性のないアサーションのタイミング アプリケーションの状態がテスト実行中に一貫性がない場合、expect/assert ステートメントがランダムに失敗するということに気づくでしょう。これに対する修正は、アサーションが一貫した状態になるのを待ってからアサートするようにテストを構築することです。そのテストが一貫した状態になるまで「待機」するステートメントについては話しません。アサートできる既知の良好な状態に達するまで、アプリケーションの状態をポーリングするための述語を用意する必要があります。 テスト順序の依存 グローバル状態はテストが他のテストに依存する主な原因です。テストを単独で実行できずスイート全体が実行されたときのみテストが成功する場合、この問題が発生しています。解決策としては各テストの実行の間に完全に状態をリセットしグローバル状態への依存性をへらすことにあります。 エンドツーエンドテスト エンドツーエンドテストは本質的に不安定です。 Write fewer of them. Instead of having 500 end to end tests for your organization, have 5.  Spotifyでの不安定なテストのトラッキング 長年に渡ってSpotifyではエンジニアリング組織全体に渡ってかなり不安定なテストを削減することに貢献したシステムを構築しました。以下にいくつかツールについての説明を共有します。
Odeneye OdeneyeはSpotifyにおけるテストスイートの可視化と不安定なテストとインフラストラクチャの問題の両者を見分けるためのシステムです。下記にあるイメージを見てください。縦にはそれぞれのテストが並び、横にCIにおけるこれらのテストの結果が表示されています。オレンジ色の点は不安定なテストを示しています。障害の実線が表示されている場合、これは通常ネットワーク障害などのインフラストラクチャの問題やその性質を示しています。このようなビューは不安定なテストやインフラストラクチャの問題を特定するために役立つ素晴らしい方法です。</description>
    </item>
    
    <item>
      <title>Increasing access to blockchain and ledger databases</title>
      <link>https://ryosan-470.github.io/tsundoku/posts/aws/qldb/</link>
      <pubDate>Sun, 24 Nov 2019 18:34:01 +0900</pubDate>
      
      <guid>https://ryosan-470.github.io/tsundoku/posts/aws/qldb/</guid>
      <description>Increasing access to blockchain and ledger databases 昨年、HARAというジャカルタにあるAWSの顧客を訪問しました。彼らは発展途上国で種子や肥料、道具といったものの配給業者や銀行と小さな農家をつなぐものを作っています。伝統的に田舎の農家は口座開設やクレジット申請に必要な情報を通常持っていないため、金融業界から無視されてきました。HARAでは小規模な農場に関するこの入手困難なデータを収集し認証しているため、これらの農家はこれまでアクセスできなかったリソースにアクセスできるようになります。
HARAが作成したシステムの主なコンポーネントはブロックチェーンでできています。この技術は複数の当事者がピアツーピアネットワークを介して会話をし、中央の信頼できる機関を持たずにイミュータブルなトランザクションを記録するアプリケーションで利用されています。HARAはEthereumという人気でオープンソースなブロックチェーンプラットフォーム上で動くアプリケーションを動作させるために追加の技術を開発しなければなりませんでした。
これはNestleやSingapore Exchangeなど、多くの顧客と共有している問題です。現在ではブロックチェーン上にスケーラブルなエンタープライズアプリケーションを構築することは時間がかかり複雑です。これらの課題を解決できない組織は取り残されています。彼らのアイデアも取り残されており、HARAのような世界をよくするようなアイデアが取り残されてしまいます。
ブロックチェーンネットワークへの関連付けの複雑性を排除するために、私達は最近、スケーラブルなブロックチェーンネットワークを簡単に構築し管理できる完全にマネージドなサービスであるAmazon Managed Blockchainを発表しました。
さらにデータ完全性のためにブロックチェーンの同じような機能を提供する元帳データベースであるAmazon Quantum Ledger Database (Amazon QLDB) も公開しました。中央の信頼できる機関のある中央集権的なシステム用に設計されています。Amazon QLDBは透明性があり、不変で、中央の信頼できる機関によって保持される暗号化された検証可能なトランザクションログを提供します。
この記事ではこれらの概念とブロックチェーンを用いて構築する人々の課題、これらの問題を解決するための2つのサービスについて深く紹介します。
ブロックチェーンと元帳技術の詳細 さて、まずブロックチェーンの背後にあるいくつかの技術を詳しくみていきましょう。元帳、合意アルゴリズム、およびスマートコントラクトです。
ブロックチェーンはデータ完全性を維持するために設計されています。それらはイミュータブルであるため、コミットされたデータの歴史を変更、または削除することはできず更新しかできません。元帳はブロックチェーンがイミュータブルであるということを用いてブロックを構築するため、これからこの概念の詳細を説明していこうとおもいます。
元帳は長い間存在しており、通常は2つ以上の当事者間の経済及び金融活動の歴史を記録するために使用されていました。メソポタミアや古代エジプトのような初期の文明でも石やパピルスを用いて元帳を使っていました。今日では貸方や借方を追跡する銀行アプリケーションが最もよく使われる元帳の例です。
ブロックチェーン (現在はAmazon QLDB) で見つかった元帳は通常次のもので構成されています。
 現在、そして歴史的な状態 : 現在と歴史の状態値を持つデータ構造により、トランザクションログ全体をたどることなく簡単にデータへアクセスできる。 ジャーナル : トランザクションログはデータ変更の全体の歴史を完全にレコードとして持っています。トランザクションログは追記のみ可能であり、つまりそれぞれの新しいレコードは以前のレコードにつながっています。そうすることでデータ変更の歴史を線形的に見ることができます。 さらに暗号化ハッシュ (各レコードに一意の識別子 (フィンガープリント) を割り当てるプロセス) を使用してブロックを互いに連鎖させます。これにより元帳にタイムキーピング属性をもたせ誰でも時間内に過去を振り返りデータトランザクションが発生したことを証明できるため監査が容易になります。  データベースは本質的には不変ではないため、顧客が監査メカニズムを設計する必要があるリレーショナルデータベースと比較してみましょう。リレーショナルデータベースにて構築されるそのような監査メカニズムはスケールすることが困難になります。それらは正しいデータがすべて記録されていることを確認するためにアプリケーション開発者に負担をかけます。
 L: 元帳データベース J: ジャーナル C | H: 現在 | 歴史  更にブロックチェーンのような分散元帳は、合意メカニズムとスマートコントラクトを実行する環境を含んでいます。
 合意アルゴリズム はネットワーク内のメンバーが元帳にトランザクションとデータをコミットするための合意手段として保証するものです。もし合意の必要性が適合しなかった場合、トランザクションはロールバックされ無効になります。 スマートコントラクト は契約に対する契約の規則および罰則がコード行に定義されているプログラムです。プログラムは契約条件が満たされたときに継続的にチェックされ、契約が自動的に実行されるようにします。  これらの要素を組み合わせることで2人以上の当事者が分散信託で取引することが可能になります。各当事者はその取引に合意し、その取引を記録します。分散型の信頼は複数の組織が独立してトランザクション履歴を検証し、単一の最新で正確なデータビューを持つ必要がある場合に意味があります。アプリケーションを維持することを望んでいる単一の当事者がいないが、ネットワークメンバーが依然として他の当事者と効率的に取引したいというときにも意味があります。
分散型の信頼が必要な貿易金融アプリケーションの例についてみてみましょう。国境をまたぐ品物の取引には輸入業者、輸出業者、複数の銀行、運送会社、保険会社、税関など多くの組織が互いに連携する必要があります。多くのステークホルダーが関わるため、信頼できる中央機関はありません。それぞれのステークホルダーは取引に関連する文書を独自に検証したいと考えており、単一の組織が活動の記録を所有することを望んでいません。
現在のプロセスでは貿易に関する事務処理 (例えば信用状など) のやり取りが必要で、完了までに5 〜 10営業日かかることがあります。これにより長い処理時間と高い費用をもたらしています。</description>
    </item>
    
    <item>
      <title>積ん読ブログHugo化してみるの巻</title>
      <link>https://ryosan-470.github.io/tsundoku/posts/hello/</link>
      <pubDate>Sun, 24 Nov 2019 17:40:21 +0900</pubDate>
      
      <guid>https://ryosan-470.github.io/tsundoku/posts/hello/</guid>
      <description>少し前から自分が読んでみたいエンジニアリングの記事のうち、主に英語で書かれているものをピックアップして、軽く訳してみたものをGitHub Pagesに上げていました。 しかし特に読みやすいように公開していたわけでもないのですがこの度重い腰を上げて、Hugoで公開してみたいと思います。
翻訳について 翻訳については素人が雰囲気で翻訳しています。もし翻訳違いなどありましたらPRを送っていただけると幸いです。
何を読もうとしているのか? 私がどんな物に興味があり何を読もうとしているかについては、イシューとプロジェクトを御覧ください。
 https://github.com/ryosan-470/tsundoku/issues https://github.com/ryosan-470/tsundoku/projects  それでは。</description>
    </item>
    
  </channel>
</rss>